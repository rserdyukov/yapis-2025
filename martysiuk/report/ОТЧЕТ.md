# Отчет

ФИО: Мартысюк Максим Юрьевич\
Группа: 221703\
Вариант: 10

## Спецификация разработанного языка программирования

#### Объявление функций

```
func <FUNCTION_NAME>(<PARAM_LIST>) (<RESULT_NAME> <TYPE>)?:
    <FUNCTION_BODY>
```

`<PARAM_LIST> = <PARAM> (, <PARAM>)*`

`<PARAM> = <IDENTIFIER> <TYPE>`

`<RESULT_NAME> = <IDENTIFIER>` (имя переменной результата, опционально)

**Примеры:**
```
func input() p point:
    x = (int)read("Введите x: ")
    y = (int)read("Введите y: ")
    return point(x, y)

func scale_point(p point, factor int) res point:
    new_x = p.x * factor
    new_y = p.y * factor
    return point(new_x, new_y)
```

#### Объявление переменных:

1. Объявление с инициализацией (автоматический вывод типа, переменная объявляется при первом присваивании):
```
<IDENTIFIER> = <EXPR>
```

**Примеры:**
```
x1 = (int)read("Enter x1: ")
p1 = point(x1, y1)
center = point(0, 0)
```

**Примечание:** Язык использует отступы (как в Python) для обозначения блоков кода, фигурные скобки не используются.

#### Управляющие конструкции:

1. if/else (используется отступ для блоков, скобки вокруг условия не обязательны): 
```
if <EXPR> then
    <BODY>
else
    <BODY>
```

**Пример:**
```
if d < 5 then
    write("Smth")
else
    write("!Smth")
```

2. while
```
while <EXPR> do:
    <BODY>
```

3. for
```
for <IDENTIFIER> = <EXPR> to <EXPR> (step = <EXPR>)?:
    <BODY>
```

4. break
```
break
```

5. return
```
return <EXPR>?
```

#### Вызовы функций:
```
<IDENTIFIER>(<ARG_LIST>)
<BUILTIN_FUNCTION>(<ARG_LIST>)
```

#### Операции над данными: 

1. Арифметические операции
```
<EXPR> + <EXPR>
<EXPR> - <EXPR>
<EXPR> * <EXPR>
<EXPR> / <EXPR>
<EXPR> % <EXPR>
```

2. Логические операции
```
<EXPR> && <EXPR>
<EXPR> || <EXPR>
!<EXPR>
```

3. Операции сравнения
```
<EXPR> >  <EXPR>
<EXPR> >= <EXPR>
<EXPR> <  <EXPR>
<EXPR> <= <EXPR>
<EXPR> == <EXPR>
<EXPR> != <EXPR>
```

4. Операция приведения типа 
```
(<TYPE>) <EXPR>
```

5. Доступ к полям объектов
```
<EXPR>.<IDENTIFIER>
```

#### Типы данных:
```
1. int 
2. bool
3. string
4. point
5. line
6. circle
7. polygon
```

#### Встроенные функции:
```
read(<STRING>?)          // чтение из консоли (возвращает string, можно привести к int)
write(<EXPR>, ...)       // вывод в консоль (принимает любое количество аргументов)
point(<int>, <int>)      // создание точки из двух координат
line(<point>, <point>)   // создание линии из двух точек
circle(<point>, <int>)   // создание окружности (центр и радиус)
polygon(<point>, ...)    // создание многоугольника (требует >=3 точек)
distance(<point>, <point>) // расстояние между двумя точками (возвращает int)
intersection(<line>, <line>) // точка пересечения двух линий (возвращает point)
inside(<point>, <circle|polygon>) // проверка принадлежности точки фигуре (возвращает bool)
```

**Примеры использования:**
```
x1 = (int)read("Enter x1: ")  // приведение результата read к int
p1 = point(x1, y1)
c = circle(p1, 5)
d = distance(p1, p2)
write("Результат: ", d)
```

## Описание грамматики

```
grammar yapis2;

tokens { INDENT, DEDENT }

program
    : functionDecl* statement* EOF
    ;

functionDecl
    : 'func' IDENTIFIER '(' parameterList? ')' (IDENTIFIER type)? ':' block
    ;

parameterList
    : parameter (',' parameter)*
    ;

parameter
    : IDENTIFIER type
    ;

type
    : 'int'
    | 'point'
    | 'line'
    | 'circle'
    | 'polygon'
    | 'bool'
    | 'string'
    ;

block
    : INDENT statement+ DEDENT
    ;

statement
    : assignment
    | variableDecl
    | ifStatement
    | whileStatement
    | forStatement
    | breakStatement
    | returnStatement
    | functionCall
    ;

assignment
    : IDENTIFIER '=' expression
    ;

variableDecl
    : IDENTIFIER '=' expression
    ;

ifStatement
    : 'if' expression 'then' block ('else' block)?
    ;

whileStatement
    : 'while' expression 'do:' block
    ;

forStatement
    : 'for' IDENTIFIER '=' expression 'to' expression ('step' '=' expression)? ':' block
    ;

breakStatement
    : 'break'
    ;

returnStatement
    : 'return' expression?
    ;

functionCall
    : IDENTIFIER '(' argumentList? ')'
    | builtInFunction '(' argumentList? ')'
    ;

argumentList
    : expression (',' expression)*
    ;

expression
    : literal                                    #literalExpr
    | IDENTIFIER                                 #identifierExpr
    | functionCall                               #functionCallExpr
    | '(' expression ')'                         #parenthesizedExpr
    | '(' type ')' expression                    #castExpr
    | '!' expression                             #notExpr
    | expression '.' IDENTIFIER                  #memberAccessExpr
    | expression op=('*' | '/' | '%') expression #multiplicativeExpr
    | expression op=('+' | '-') expression       #additiveExpr
    | expression op=('<' | '>' | '<=' | '>=' | '==' | '!=') expression #comparisonExpr
    | expression op=('&&' | '||') expression     #logicalExpr
    ;

builtInFunction
    : 'read'
    | 'write'
    | 'point'
    | 'line'
    | 'circle'
    | 'polygon'
    | 'distance'
    | 'intersection'
    | 'inside'
    ;

literal
    : INT
    | STRING
    | BOOL
    ;

IDENTIFIER: [a-zA-Z_][a-zA-Z_0-9]*;

INT: [0-9]+;

BOOL: 'true' | 'false';

STRING: '"' (~["\r\n])* '"';

NEWLINE: ('\r'? '\n' | '\r') [ \t]*;

WS: [ \t]+ -> skip;

COMMENT: '//' ~[\r\n]* -> skip;
```

## Описание разработанных компонентов:

#### Классы

1. **`SemanticAnalyzer`** - класс выполняет семантический анализ программы на основе дерева, построенного парсером. Проверяет типы, области видимости переменных, корректность вызовов функций, соответствие типов в операциях.

2. **`Compiler`** - класс отвечает за трансляцию дерева разбора в целевой код (JVM байт-код в формате Jasmin). Генерирует классы для типов данных (Point, Line, Circle, Polygon), методы для функций, основной метод main, преобразует операции языка в инструкции JVM.

3. **`VerboseErrorListener`** - класс обрабатывает синтаксические ошибки, генерируемые парсером ANTLR. Собирает ошибки и выводит их с указанием строки и позиции.

4. **`Main`** - класс осуществляющий запуск программы (синтаксический анализ → семантический анализ → кодогенерация).

#### Основные методы

**SemanticAnalyzer:**
- `visitProgram` - обход программы, регистрация функций
- `visitFunctionDecl` - проверка объявления функции
- `visitVariableDecl` - проверка объявления переменной
- `visitAssignment` - проверка присваивания
- `visitReturnStatement` - проверка оператора return
- `visitIfStatement`, `visitWhileStatement`, `visitForStatement` - проверка управляющих конструкций
- `visitFunctionCall` - проверка вызова функции
- `infer_type` - определение типа выражения
- `check_builtin_call` - проверка вызова встроенных функций

**Compiler:**
- `visitProgram` - генерация основного класса и методов
- `generate_type_class_files` - генерация Java-классов для типов (Point, Line, Circle, Polygon)
- `visitFunctionDecl` - генерация кода для функции
- `generate_main` - генерация метода main
- `visitStatement` - генерация кода для операторов
- `visitExpression` - генерация кода для выражений
- `generate_builtin_call` - генерация кода для встроенных функций
- `type_to_jvm` - преобразование типов языка в JVM типы

#### Остальные файлы

1. `run_example.py` - скрипт для автоматической компиляции и запуска примеров
2. `yapis2.g4` - грамматика языка в формате ANTLR4
3. `gen/` - сгенерированные файлы парсера (lexer, parser, visitor)

## Перечень генерируемых ошибок

1. Функция уже объявлена (перегрузка запрещена)
2. Повторное объявление параметра функции
3. Переменная уже объявлена в текущей области видимости
4. Невозможно присвоить значение одного типа переменной другого типа
5. Использование переменной вне области видимости
6. Оператор return вне функции
7. Функция должна возвращать значение, но return отсутствует
8. Функция не должна возвращать значение, но return с выражением
9. Функция должна возвращать значение определенного типа, но возвращается другой тип
10. Условие if должно быть типа bool
11. Условие while должно быть типа bool
12. Начальное/конечное значение for должно быть int
13. Шаг for должен быть int
14. Вызов необъявленной функции
15. Неверное количество аргументов функции
16. Неверный тип аргумента функции
17. Унарный оператор ! применим только к bool
18. Логические операции требуют операнды bool
19. Сравнение типов должно быть между одинаковыми типами
20. Функция 'polygon' требует >=3 точек
21. Неверные типы аргументов для встроенных функций (point, line, circle, polygon, distance, intersection, inside)

## Демонстрация работы

### Пример 1: Базовые операции с точками и окружностями

**Код:**
```
// Example: 1

x1 = (int)read("Enter x1: ")// пользовательский ввод
y1 = (int)read("Enter y1: ")
x2 = (int)read("Enter x2: ")
y2 = (int)read("Enter y2: ")

p1 = point(x1, y1)// две координаты передаем
p2 = point(x2, y2)
c = circle(p1, 5)// передаем точку и радиус

d = distance(p1, p2)// расстояние между точками (distance - встроенная функция)

if d < 5 then
    write("Smth")
else
    write("!Smth")
```

**Вывод:**
```
Enter x1: 10
Enter y1: 10
Enter x2: 15
Enter y2: 15
!Smth
```

### Пример 2: Циклы и проверка принадлежности точки окружности

**Код:**
```
// Example: 2
// Task: Проверка принадлежности точек окружности

func input() p point:
    x = (int)read("Введите x: ")
    y = (int)read("Введите y: ")
    return point(x, y)

center = point(0, 0)
c = circle(center, 10)

for i = 1 to 5 step = 2:
    p = input()
    attempt = 0
    while !(inside(p, c)) do: // пока точка не внутри пробуем
        write("Точка вне круга, повторите ввод")
        p = input()
        attempt = attempt + 1
        if attempt > 3 then
            write("Слишком много попыток")
            break
    write("Точка подходит: ", p)
```

**Вывод:**
```
Введите x: 15
Введите y: 15
Точка вне круга, повторите ввод
Введите x: 5
Введите y: 5
Точка подходит: (5, 5)
Введите x: 3
Введите y: 3
Точка подходит: (3, 3)
```

### Пример 3: Функции для работы с точками

**Код:**
```
// Example: 3

func scale_point(p point, factor int) res point:
    new_x = p.x * factor
    new_y = p.y * factor
    return point(new_x, new_y)

func midpoint(p1 point, p2 point) res point:
    res_x = (p1.x + p2.x) / 2
    res_y = (p1.y + p2.y) / 2
    return point(res_x, res_y)

p1 = point(2, 4)
p2 = point(6, 8)

write("Исходные точки: ", p1, p2)

scaled_point = scale_point(p1, 2)
write("Масштабированная точка: ", scaled_point)

mpoint = midpoint(p1, p2)
write("Середина между точками: ", mpoint)
```

**Вывод:**
```
Исходные точки: (2, 4) (6, 8)
Масштабированная точка: (4, 8)
Середина между точками: (4, 6)
```

### Пример 4: Работа с многоугольниками и линиями

**Код:**
```
// Example: 4

func midpoint(p1 point, p2 point) res point:
    mx = (p1.x + p2.x) / 2
    my = (p1.y + p2.y) / 2
    return point(mx, my)

func clamp_to_polygon(p point, poly polygon) res point:
    attempt = 0
    current = p
    while !(inside(current, poly)) do:
        // простая проекция: сжимаем координаты, пока не попадем внутрь
        current = point(current.x / 2, current.y / 2)
        attempt = attempt + 1
        if attempt > 5 then
            break
    return current

// Опорные точки и фигуры
a = point(0, 0)
b = point(10, 0)
c = point(10, 10)
d = point(0, 10)
square = polygon(a, b, c, d)

main_diag = line(a, c)
cross_diag = line(b, d)
center = intersection(main_diag, cross_diag)

p_outside = point(20, 5)
p_inside = clamp_to_polygon(p_outside, square)

write("Центр квадрата: ", center)
write("Точка после проекции внутрь: ", p_inside)

// Серия измерений расстояний до центра
for i = 1 to 3:
    target = point(i * 3, i * 4)
    dist = distance(target, center)
    if dist > 8 then
        write("Далеко: ", target, " (расстояние = ", dist, ")")
    else
        write("Близко: ", target, " (расстояние = ", dist, ")")
```

**Вывод:**
```
Центр квадрата: (5, 5)
Точка после проекции внутрь: (5, 2)
Близко: (3, 4) (расстояние = 2)
Близко: (6, 8) (расстояние = 3)
Далеко: (9, 12) (расстояние = 9)
```

