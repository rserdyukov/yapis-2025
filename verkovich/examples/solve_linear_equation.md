### Пример 1: Решение СЛАУ через LU-разложение

```mcl
# ==============================================================================
# Пример 1: Решение системы линейных уравнений A*x = b методом LU-разложения
# Демонстрирует:
# - Определение и вызов пользовательских функций.
# - Использование tuple для возврата и распаковки нескольких значений (матриц).
# - Итерационные циклы for..in..range() для прямого и обратного прохода.
# - Базовые матричные и векторные операции, включая доступ к элементам.
# - Двухвариантный условный оператор if-else.
# ==============================================================================

# -- Все функции требуется объявляють в начале программы --

# Функция прямой подстановки для решения системы Ly = b
func forward_substitution(L: matrix, b: vector) -> vector:
    n = dimension(b)
    # Инициализация вектора y нулями с помощью встроенной функции
    y = zeros(n)
    
    # Итерация от 0 до n-1
    for i in range(n):
        sum_val = 0.0
        for j in range(i):
            sum_val = sum_val + L[i][j] * y[j]
        
        y[i] = (b[i] - sum_val) / L[i][i]
    return y

# Функция обратной подстановки для решения системы Ux = y
func backward_substitution(U: matrix, y: vector) -> vector:
    n = dimension(y)
    x = zeros(n)
    
    # Итерация от n-1 до 0 с шагом -1
    for i in range(n - 1, -1, -1):
        sum_val = 0.0
        for j in range(i + 1, n):
            sum_val = sum_val + U[i][j] * x[j]
        
        x[i] = (y[i] - sum_val) / U[i][i]
    return x

# --- Начало основной программы ---

# Инициализация матрицы A и вектора b с помощью литералов.
# Тип элементов (float) выводится автоматически из-за наличия `2.`
A = {{2., 3., 1.}, {1., 1., 3.}, {3., 2., 1.}}
b = {4., 0., 2.}

write("Решаем систему A*x = b для:")
write("Матрица A:")
write(A)
write("Вектор b:")
write(b)

# Проверка корректности решения с помощью условного оператора if-then-else
det_A = |A|
if det_A == 0:
    write("Система не имеет единственного решения, определитель равен нулю.")
else:
    # Встроенная функция LU(), которая возвращает tuple из двух матриц
    lu_decomp = LU(A)
    L = lu_decomp[0]
    U = lu_decomp[1]
    
    write("Нижняя треугольная матрица L:")
    write(L)
    write("Верхняя треугольная матрица U:")
    write(U)
    
    # L*y = b
    y = forward_substitution(L, b)
    
    # U*x = y
    x = backward_substitution(U, y)
    
    write("Найденный вектор решений x:")
    write(x)
```
