# Спецификация языка Matrix Computing Language (MCL)

Язык вычисления матриц - это скриптовый высокоуровневый DSL-язык программирования, предназначенный для работы с матрицами и векторами, а также с возможностью работы со скалярами.
Основная задача - вычисления на встроенный структурах данных (типах) которые представляют собой
одно- и двумерные массивы чисел.
Таким образом язык предоставляет абстракции над мат.объектами и операциями над ними.

Язык преследует, с одной стороны, образовательные цели - изучение студентами основ линейной алгебры, а также улучшение у них навыков программирования на языке сценариев. С другой стороны, язык может быть полезен как средство автоматизации рутинных задач в различных областях, требующих соответствующих расчетов: инженерии, анализе данных и т.д.

## Типы данных

Рассмотрим встроенные типы и зарезервированные значения, и работу над ними

- Скалярные типы (тензоры размерности 0):
 Типы, представляющие собой числа(скаляры):
    - `int` - целые числа
    - `float` - числа с плавающей точкой
Мутабельные типы

- Векторный тип (тензоры размерности 1):
    - `vector` - одномерный массив чисел, фиксированного размера.
Иммутабельный тип

- Матричный тип (тензоры размерности 2):
    - `matrix` - двумерный массив чисел, фиксированной размерности.
Иммутабельный тип

- Коллекция элементов:
    - `tuple` - неизменяемая коллекция элементов, позволяющая хранить набор значений всех типов

- Было решено не вводить конструкции типа null, допускающих отсутствие значения. Язык требует инициализации переменной, поскольку:
    - Семантика языка математических вычислений не предполагает "пустых" значений. 
    - Позволяет избежать ошибок времени выполнения, что повышает надежность, а также избавляет от надобности большого числа проверок. Чистота + надежность.
    - Требовалось бы определять смысл и поведение null для различных специфических случаев, что также неоправдано усложнило бы язык.

- Для специфических случаев, когда значение не определено в математическом смысле, предусмотрены встроенные в язык значения:
    - `NaN` - "не число", результат математически неоредеелнных операций (0.0/0.0, Infinity-Infinity etc.)
    - `Infinity` - положительная бесконечность
    - `-Infinity` - отрицательная бесконечность
Это специфические значения, которые может принимать тип float при неопределнности или переполнении.
Для целочисленного `int` переполнение и неопределенное поведение приведёт к ошибке рантайма.

- Логический тип:
    - `boolean` - принимает значения `true` и `false`. Результат вычисления операций сравнения имеет этот тип. Нужен для работы с циклами и условными конструкциями.

- Строковый тип:
    - `string` - тип данных позволяющих хранить данные в текстовом виде для операций ввода вывода. 


```
#--------создание переменных и преобразование типов
# целое число
num = 2

#число с плавающей запятой
num_f = 2. #2.0000000000000000000000... сколько там оно будет памяти занимать
num_f = 3.560209

#вектор и матрица
v_1 = {1,3.112,-4,9,0} #задание вектора перечислением
v_2 = [5] #{0,0,0,0,0} - вектор размера 5, заполняется стандартным значением 0
v_3 = [7](4) #{4,4,4,4,4,4,4} - вектор размера 7, заполняется значением 4

m_1 = {{1,2,3},{4,5.4,6},{7,8,9.}} #задание перечислением
m_2 = [2][2] #  {{0,0},{0,0}} # матрица заполненная нулями 2х2
m_3 = [3][3](1.2) #  {{1.2,1.2,1.2},{1.2,1.2,1.2},{1.2,1.2,1.2}} # заполнение матрицы 3x3 единицами

# язык поддерживает и явное указание типов (согласно требованию №2 из "требования к языку")
int? val = -45
vector<int>? vec = [3]

# важно отметить что язык, на данный момент, ЗАПРЕЩАЕТ пустые векторы/матрицы:
empty_vec = {}
empty_mtrx = {{}}

# язык требует явного преобразования типов между скалярными значениями. Для матричных преобразования не   допускаются в силу неочевидного поведения

num = (float) num_f # расширяющее преобразование
num_f = (int) num_f # сужающее преобразование - отбрасывает десятичную часть без учета округления


``` 

Выведение типов работает по следующим правилам:

int <op> int → int
float <op> float → float
int <op> float → float
float <op> int → float

Тип контейнеров определяется по содержимому - если в результате операции возникает float или он есть внутри операндов, то float.

Исключения: скалярное произведение векторов, норма вектора, вычисление определителя - возвращает скаляр
умножение матрицы на вектор и наоброт - дает вектор
операция доступа к строке матрицы - вектор
операции допуста к элементу - скаляр

## Встроенные функции языка

Язык предоставляет встроенные функции для работы с матрицами

```
# ------генерация типовых матриц и векторов или по паттернам
# заполнение целочисленными нулями
v = zeros(size) 
m = zeros(rows, cols)

# заполнение целочисленными единицами
v = ones(size)
m = ones(rows, cols)

# возвращает единичную матрицу (sxs) (единицы на главной диагонали)
m = identity(s) 

# генерирует вектор/матрицу размера size, заполненную рандомными целыми значениями
v = random_int(size, limit) # рандомные числа от 0 до limit
v = random_int(size, start, limit) # рандомные числа от start до limit
m = random_int(rows, cols, limit) # рандомные числа от 0 до limit
m = random_int(rows, cols, start, limit) # рандомные числа от start от limit

# заполняет вектор/матрицу рандомными десятичными значениями [0.0, 1.0]
v = random_float(size)
m = random_float(rows, cols)

# заполняет вектор значениями в промежутке:
v = range(limit)
v = range(start, limit)
v = range(start, limit, step)


# генерирует диагональную матрицу с вектором на главной диагонали
m = diag(vector)

# -------утилитные встроенные функции

# транспонирует матрицу
m = transpose(m) 

# возвращает размеронсть вектора/матрицы
int vector_dimension = dimension(v) # возвращает целое число
tuple matrix_dimension = dimension(m) # возвращает tuple (cols, rows)

# генерирует треугольную матрицу на основе существующей
m = triag_upper(m) # верхняя треугольная матртица
m = triag_lower(m) # нижняя треугольная матрица

# производит LU-разложение матрицы
lu_decomp = LU(m) # возращает tuple из двух матриц

# обращает матрицу
m = inverse(m) #  A^(-1) = inverse(A)
```

---

### Встроенные операции и выражения

Язык предоставляет набор встроенных инфиксных и префиксных операторов для выполнения математических вычислений над его основными типами данных. Во всех операциях, требующих совпадения размерностей, несоответствие приводит к ошибке времени выполнения.

#### Операции с векторами

*   **Сложение векторов:** `v1 + v2`
    *   **Описание:** Выполняется поэлементное сложение двух векторов. Векторы должны иметь одинаковую размерность.
    *   **Результат:** `vector` той же размерности.

*   **Вычитание векторов:** `v1 - v2`
    *   **Описание:** Выполняется поэлементное вычитание. Векторы должны иметь одинаковую размерность.
    *   **Результат:** `vector` той же размерности.

*   **Умножение вектора на скаляр:** `n * v` (или `v * n`)
    *   **Описание:** Каждый элемент вектора `v` умножается на скаляр `n`.
    *   **Результат:** `vector` той же размерности, что и `v`.

*   **Скалярное произведение векторов:** `v1 * v2`
    *   **Описание:** Вычисляется скалярное (dot) произведение двух векторов. Векторы должны иметь одинаковую размерность.
    *   **Результат:** скаляр (`int` или `float`).

*   **Норма (длина) вектора:** `|v|`
    *   **Описание:** Вычисляется евклидова норма (L2-норма или длина) вектора.
    *   **Результат:** скаляр (`float`).

#### Операции с матрицами

*   **Сложение матриц:** `m1 + m2`
    *   **Описание:** Выполняется поэлементное сложение двух матриц. Матрицы должны иметь одинаковые размерности (одинаковое число строк и столбцов).
    *   **Результат:** `matrix` тех же размерностей.

*   **Вычитание матриц:** `m1 - m2`
    *   **Описание:** Выполняется поэлементное вычитание. Матрицы должны иметь одинаковые размерности.
    *   **Результат:** `matrix` тех же размерностей.

*   **Умножение матрицы на скаляр:** `m * n` (или `n * m`)
    *   **Описание:** Каждый элемент матрицы `m` умножается на скаляр `n`.
    *   **Результат:** `matrix` тех же размерностей, что и `m`.

*   **Матричное умножение:** `m1 * m2`
    *   **Описание:** Выполняется стандартное матричное умножение. Количество столбцов в матрице `m1` должно быть равно количеству строк в матрице `m2`.
    *   **Результат:** `matrix` с размерностью (количество строк `m1` x количество столбцов `m2`).

*   **Определитель матрицы:** `|m|`
    *   **Описание:** Вычисляется определитель (детерминант) матрицы. Матрица `m` должна быть квадратной.
    *   **Результат:** скаляр (`int` или `float`).

#### Операции доступа и смешанные операции

*   **Умножение вектора на матрицу:** `v * m`
    *   **Описание:** Вектор-строка `v` умножается на матрицу `m`. Размерность вектора `v` должна быть равна количеству строк в матрице `m`.
    *   **Результат:** `vector`, размерность которого равна количеству столбцов в матрице `m`.

*   **Доступ к строке матрицы:** `m[n]`
    *   **Описание:** Возвращает `n`-ую строку матрицы `m` (индексация начинается с нуля). `n` должно быть целым числом.
    *   **Результат:** `vector`.

*   **Комбинированная операция:** `m[n] * n`
    *   **Описание:** Это пример составного выражения. Сначала происходит получение `n`-ой строки матрицы (`m[n]`), которая является вектором, а затем этот вектор умножается на скаляр `n`.
    *   **Результат:** `vector`.


### Ввод/вывод

Для взаимодействия с внешним миром язык предоставляет две встроенные функции: `read()` и `write()`.

#### Функция `read()`
Считывает данные из стандартного потока ввода.

*   **Сигнатура:** `read()` → `int | float | vector | matrix | boolean`
*   **Описание:** Функция считывает одну строку из потока ввода и пытается автоматически распознать и преобразовать её в один из базовых типов языка. Порядок распознавания: `boolean` (`true`/`false`), `int`, `float`, `vector`, `matrix`. Если строку не удается преобразовать ни в один из типов, возникает ошибка времени выполнения.
*   **Пример:**
    ```
    write("Введите размерность матрицы n:")
    n = read() #  Пользователь вводит 5, n становится int со значением 5
    
    write("Введите матрицу в формате {{1,2},{3,4}}:")
    m = read() #  m становится объектом matrix
    ```

#### Функция `write()`
Выводит данные в стандартный поток вывода.

*   **Сигнатура:** `write(value: any)`
*   **Описание:** Принимает один аргумент любого типа и выводит его строковое представление в стандартный поток вывода, завершая его символом новой строки.
*   **Пример:**
    ```
    m = identity(2)
    write("Единичная матрица:")
    write(m) #  Выведет что-то вроде: {{1, 0}, {0, 1}}
    ```
---

#### Взаимодействие с файлами

Для удобной работы с большими объемами данных, такими как векторы и матрицы, предусмотрены функции для чтения и записи файлов.

##### Функция `read_file()`
Считывает вектор или матрицу из файла.

*   **Сигнатура:** `read_file(path: string) -> vector | matrix`
*   **Описание:** Функция принимает строковый путь к файлу, считывает его содержимое и преобразует в объект типа `vector` или `matrix`. Формат данных определяется автоматически на основе структуры файла. Поддерживаются текстовые файлы (`.txt`) и файлы с разделителями-запятыми (`.csv`). При возникновении ошибки (файл не найден, некорректный формат данных) выполнение программы прерывается с ошибкой времени выполнения.
*   **Форматы данных:**
    *   **Вектор:** Однострочный файл, где элементы разделены пробелами (`.txt`) или запятыми (`.csv`).
    *   **Матрица:** Многострочный файл, где каждая строка представляет собой строку матрицы. Элементы в строке разделены пробелами (`.txt`) или запятыми (`.csv`). Все строки должны содержать одинаковое количество элементов.
*   **Пример:**

    Предположим, есть файл `data.csv` со следующим содержимым:
    ```csv
    1.5,2.0,3.1
    4.0,5.5,6.0
    7.2,8.0,9.9
    ```

    Код для чтения этого файла:
    ```mcl
    # Загружаем матрицу из файла
    my_matrix = read_file("data.csv")
    
    # my_matrix теперь содержит {{1.5, 2.0, 3.1}, {4.0, 5.5, 6.0}, {7.2, 8.0, 9.9}}
    write(my_matrix)
    ```

##### Функция `write_file()`
Записывает вектор или матрицу в файл.

*   **Сигнатура:** `write_file(path: string, data: vector | matrix)`
*   **Описание:** Функция принимает строковый путь к файлу и данные (`vector` или `matrix`), после чего записывает их в указанный файл. Если файл уже существует, он будет перезаписан. Формат записи определяется расширением файла в пути:
    *   `.csv`: элементы разделяются запятыми.
    *   `.txt`: элементы разделяются пробелами.
    *   Другие расширения: по умолчанию используется формат `.txt`.

*   **Пример:**
    
    ```mcl
    # Создаем матрицу 3x3
    m = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
    
    # Сохраняем её в CSV файл
    write_file("output.csv", m)
    ```
    В результате будет создан файл `output.csv` со следующим содержимым:
    
    ```csv
    1,2,3
    4,5,6
    7,8,9
    ```


---

## Управляющие конструкции

Управляющие конструкции изменяют последовательный ход выполнения программы. Блоки кода, относящиеся к конструкциям, определяются уровнем отступа.

### Условный оператор
Выполняет один из двух блоков кода в зависимости от истинности логического выражения.

*   **Синтаксис `if-then-else`:**
    ```
    if <condition>:
        <then-block>
    else:
        <else-block>
    ```
*   **Синтаксис `if-then`:**
    ```
    if <condition>:
        <then-block>
    ```
*   **Описание:** Вычисляется `<condition>`, результат которого должен быть типа `boolean`. Если `true`, выполняется `<then-block>`. Если `false`, выполняется `<else-block>`, если он присутствует.

### Операторы цикла

#### Условный цикл `while`
Выполняет блок кода, пока условие истинно. Условие проверяется *перед* каждой итерацией.

*   **Синтаксис:**
    ```
    while <condition>:
        <loop-body>
    ```

#### Условный цикл `until`
Выполняет блок кода, пока условие ложно. Является синтаксическим эквивалентом `while not(<condition>)`.

*   **Синтаксис:**
    ```
    until <condition>:
        <loop-body>
    ```

#### Итерационный цикл `for`
Выполняет итерацию по элементам итерируемого объекта. Итерируемыми являются `vector`, `matrix` и результат функции `range()`.

*   **Синтаксис:**
    ```
    for <variable> in <iterable>:
        <loop-body>
    ```
*   **Поведение итерации:**
    *   При итерации по `vector`, переменная `<variable>` последовательно принимает значения его скалярных элементов.
    *   При итерации по `matrix`, `<variable>` последовательно принимает значения его строк, каждая из которых является объектом `vector`.

---

## Пользовательские функции

Пользователь может определять собственные подпрограммы для инкапсуляции и повторного использования кода.

### Синтаксис определения
*   **Синтаксис:**
    ```
    func <name>(<param1>: <type1>, <param2>: <type2>, ...) -> <return_type>:
        <function-body>
        return <value>
    ```
*   **Описание:**
    *   `func`: Ключевое слово для определения функции.
    *   `<name>`: Уникальное имя функции.
    *   `<param...>: <type...>`: Список именованных параметров с обязательным указанием их типов.
    *   `-> <return_type>`: Обязательное указание типа возвращаемого значения. Если функция не должна возвращать значение, используется специальный тип `void`.
    *   `return <value>`: Оператор для возврата значения из функции. Тип `<value>` должен соответствовать `<return_type>`.

*   **Пример:**
    ```
    #  Функция для нормализации вектора
    func normalize(v: vector) -> vector:
        norm = |v|
        if norm == 0:
            return v #  Возвращаем исходный нулевой вектор
        
        return v * (1.0 / norm)
    
    vec = {3, 4}
    norm_vec = normalize(vec)
    write(norm_vec) #  Вывод: {0.6, 0.8}
    ```

### Особенности вызова и определения
*   **Отсутствие перегрузки:** В языке запрещено определять несколько функций с одинаковым именем, даже если у них разные наборы параметров. Каждое имя функции должно быть уникальным.

*   **Передача параметров строго по значению:** При вызове функции для каждого параметра создается его локальная копия.
    *   Для скалярных типов (`int`, `float`, `boolean`) копируется само значение.
    *   Для иммутабельных контейнерных типов (`vector`, `matrix`) также создается копия. Это гарантирует, что функция **ни при каких обстоятельствах не может изменить** переменную, переданную в нее извне, обеспечивая отсутствие побочных эффектов. 

---

### Анонимные функции (Лямбды)

Для повышения выразительности языка и предоставления мощных инструментов для генерации данных, MCL поддерживает концепцию **анонимных функций**, также известных как лямбда-функции. Лямбды позволяют определять небольшие, одноразовые функции прямо в месте их использования, без необходимости давать им имя.

#### Синтаксис и семантика

Лямбда-функция в MCL определяется с помощью ключевого слова `lambda`, за которым следует список параметров, двоеточие и одно-единственное выражение, результат вычисления которого будет возвращен функцией.

*   **Общий синтаксис:** `lambda <param1>, <param2>, ...: <expression>`

*   **Особенности:**
    *   **Тело-выражение:** Тело лямбды не может содержать управляющие конструкции или несколько операторов; оно должно состоять из одного выражения.
    *   **Область видимости:** Лямбда имеет доступ только к своим входным параметрам и к глобально определенным функциям (например, встроенным). Она **не захватывает** локальные переменные из контекста, в котором она создается (отсутствие замыканий). Это ограничение упрощает реализацию и повышает предсказуемость кода.

#### Использование лямбда-функций

Основное применение лямбд в MCL — это функциональная инициализация векторов и матриц. Специальный синтаксис конструктора позволяет передать лямбду, которая будет вычислена для каждого элемента будущей коллекции.

#### Инициализация векторов

При создании вектора в лямбда-функцию передается один целочисленный аргумент — индекс создаваемого элемента `i`.

*   **Синтаксис:** `[<size>](lambda i: <expression>)`
*   **Пример:**
    ```mcl
    # Создать вектор из 5 элементов, где каждый элемент равен своему индексу в квадрате
    # Результат: {0, 1, 4, 9, 16}
    squares = [5](lambda i: i * i)
    
    # Создать вектор из 4 элементов, где каждый элемент равен 2^i
    # Результат: {1, 2, 4, 8}
    powers_of_two = [4](lambda i: 2^i)
    ```

#### Инициализация матриц

При создании матрицы в лямбда-функцию передаются два целочисленных аргумента — индекс строки `i` и индекс столбца `j`.

*   **Синтаксис:** `[<rows>][<cols>](lambda i, j: <expression>)`
*   **Пример:**
    ```mcl
    # Создать единичную матрицу 3x3
    # Результат: {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}
    identity_m = [3][3](lambda i, j: 1 if i == j else 0)
    
    # Создать матрицу 2x3, где значение элемента равно сумме его индексов
    # Результат: {{0, 1, 2}, {1, 2, 3}}
    sum_m = [2][3](lambda i, j: i + j)
    
    # Создать "шахматную доску"
    # Результат: {{1, 0, 1}, {0, 1, 0}, {1, 0, 1}}
    chessboard = [3][3](lambda i, j: (i + j) % 2) 
    ```   

---


## Логические операции и операции сравнения

Для построения сложных логических условий в управляющих конструкциях (таких как `if`, `while`, `until`) и в тернарных выражениях язык поддерживает стандартный набор операторов сравнения и логических операторов.

### Операторы сравнения

Эти операторы принимают два скалярных операнда (`int` или `float`) и возвращают результат типа `boolean`.

*   `==` — Равно
*   `!=` — Не равно
*   `>` — Больше
*   `<` — Меньше
*   `>=` — Больше или равно
*   `<=` — Меньше или равно

**Пример:**
```mcl
is_positive = my_var > 0
are_equal = count == 10
```

### Логические операторы

Эти операторы работают с операндами типа `boolean` и используются для комбинирования результатов операций сравнения.

*   **Логическое И:** `and`
    *   **Описание:** `expr1 and expr2`. Возвращает `true`, только если оба выражения (`expr1`, `expr2`) истинны.
*   **Логическое ИЛИ:** `or`
    *   **Описание:** `expr1 or expr2`. Возвращает `true`, если хотя бы одно из выражений (`expr1`, `expr2`) истинно.
*   **Логическое НЕ:** `not`
    *   **Описание:** `not expr`. Инвертирует логическое значение выражения `expr` (превращает `true` в `false` и наоборот).


### Условное выражение (тернарный оператор)

Позволяет выбрать одно из двух значений в рамках одного выражения.

*   **Синтаксис:** `<значение_если_true> if <условие> else <значение_если_false>`
*   **Описание:** Вычисляется `<условие>`: если оно истинно, возвращается `<значение_если_true>`, в противном случае — `<значение_если_false>`.
*   **Пример:**
    ```mcl
    
    identity_m = [3][3](lambda i, j: 1 if i == j else 0)
    ```

### Приоритет операций

Логические операторы и операторы сравнения имеют следующий приоритет (от высшего к низшему):

1.  Арифметические операторы (`*`, `+`, `-`, ...).
2.  Операторы сравнения (`>`, `==`, `!=`, ...).
3.  Логическое `not`.
4.  Логическое `and`.
5.  Логическое `or`.

Скобки `()` могут использоваться для явного управления порядком вычислений.

**Пример использования:**
```mcl
x = 10
y = -5
is_valid = true

if (x > 0 and y < 0) or not is_valid:
    write("Условие выполнено!")

frame_matrix = [4][4](lambda r, c: 1 if r == 0 or r == 3 or c == 0 or c == 3 else 0)
```

---






