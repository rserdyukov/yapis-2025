# Лабораторная работа 1
## По дисциплине "Языковые процессоры интеллектуальных систем"
---
### ТЗ 

Написать 3 примера фрагментов кода языка по варианту, все свойства должны быть использованы, встроенные типы, операции и функции должны быть использованы и показаны на примерах.

### Вариант задания

Вариант 2

Требования к разрабатываемому языку:
- Встроенные типы не менее трех
- Возможность инициализация переменных всех типов при объявлении: <тип>? <имя_переменной> = <выражение>
- Инициализирующее выражение может быть константным
- Встроенные операции не менее 10 штук
- Встроенные функции
- Встроенные функции ввода\вывода для работы со встроенными типами read() write()
- Использование сложных выражений (составных и со скобками)
- Блочный оператор
- Управляющие структуры
- Условный оператор (if-then-else)
- Операторы цикла (while и until)
- Оператор цикла с итерациями (for)
- Пользовательские подпрограммы
- Передача и возврат параметров
- Задание локальной и глобальной области видимости для имен переменных


Свойства языка:
- Объявление переменных - **Не явное**
- Преобразование типов - **Явное, например, a = (int) b**
- Оператор присваивания - **Одноцелевой, например, a = b**
- Структуры, ограничивающие область видимости - **Подпрограммы**
- Маркер блочного оператора - **Не явный, например как в python**
- Условные операторы - **Двух вариантный оператор if-then-else**
- Перегрузка подпрограмм - **Отсутствует**
- Передача параметров в подпрограмму - **Только по значению и возвращаемому значению**
- Допустимое место объявления подпрограмм - **В начале программы**

Вариант языка:
Язык для работы с векторами и матрицами
 - Встроенные типы: vector, matrix
 - Операции: 
    - v + v
    - v - v
    - n * v
    - v * v
    - |v|
    - m + m
    - m - m
    - m * n
    - m * m
    - m[n]
    - m[n] * n
    - |m|
    - v * m


Вариант целевого кода:
 - байт-код аля CPython (.pyc)

---

## Ход работы 

Разработка концепта языка программирования **Matrix Computing Language (MCL)** велась как систематический, поэтапный процесс, где каждый следующий шаг логически вытекал из предыдущего. Фундаментом для всей работы послужил детальный анализ технического задания и итеративная проработка концепции языка.

Начальной точкой стало изучение требований и свойств, изложенных в варианте задания. Такие ключевые свойства, как неявное объявление переменных, неявный маркер блока и передача параметров по значению, а также семантика языка сразу определили общую философию MCL как скриптового языка с элементами функционального стиля, ориентированного на простоту и предсказуемость. Таким образом язык, в сущности, является ориентированным на математические вычисления.

В результате итеративного процесса текстового рассуждения была написана (спецификация)[DOCS.md] языка, которая позволила создать выразительные решения для задач, решаемых языком. Для полноценной поддержки функционала, требуемого в практикуме, было разработано множество дополнительных конструкций, операторов, встроенных функций, благодаря которым язык имеет перспективы для развития в мощный инструмент в своей предметной области.

Согласно спецификации языка MCL, были разработаны цельные и осмысленные фрагменты кода, которые послужат подспорьем для формализации грамматики языка с помощью средств ANTLR, и последующей разрабтоки языкового процессора.

Рассмотрим примеры:

---

### Пример 1: Решение СЛАУ через LU-разложение

```mcl
# ==============================================================================
# Пример 1: Решение системы линейных уравнений A*x = b методом LU-разложения
# Демонстрирует:
# - Определение и вызов пользовательских функций.
# - Использование tuple для возврата и распаковки нескольких значений (матриц).
# - Итерационные циклы for..in..range() для прямого и обратного прохода.
# - Базовые матричные и векторные операции, включая доступ к элементам.
# - Двухвариантный условный оператор if-else.
# ==============================================================================

# -- Все функции требуется объявляють в начале программы --

# Функция прямой подстановки для решения системы Ly = b
func forward_substitution(L: matrix, b: vector) -> vector:
    n = dimension(b)
    # Инициализация вектора y нулями с помощью встроенной функции
    y = zeros(n)
    
    # Итерация от 0 до n-1
    for i in range(n):
        sum_val = 0.0
        for j in range(i):
            sum_val = sum_val + L[i][j] * y[j]
        
        y[i] = (b[i] - sum_val) / L[i][i]
    return y

# Функция обратной подстановки для решения системы Ux = y
func backward_substitution(U: matrix, y: vector) -> vector:
    n = dimension(y)
    x = zeros(n)
    
    # Итерация от n-1 до 0 с шагом -1
    for i in range(n - 1, -1, -1):
        sum_val = 0.0
        for j in range(i + 1, n):
            sum_val = sum_val + U[i][j] * x[j]
        
        x[i] = (y[i] - sum_val) / U[i][i]
    return x

# --- Начало основной программы ---

# Инициализация матрицы A и вектора b с помощью литералов.
# Тип элементов (float) выводится автоматически из-за наличия `2.`
A = {{2., 3., 1.}, {1., 1., 3.}, {3., 2., 1.}}
b = {4., 0., 2.}

write("Решаем систему A*x = b для:")
write("Матрица A:")
write(A)
write("Вектор b:")
write(b)

# Проверка корректности решения с помощью условного оператора if-then-else
det_A = |A|
if det_A == 0:
    write("Система не имеет единственного решения, определитель равен нулю.")
else:
    # Встроенная функция LU(), которая возвращает tuple из двух матриц
    lu_decomp = LU(A)
    L = lu_decomp[0]
    U = lu_decomp[1]
    
    write("Нижняя треугольная матрица L:")
    write(L)
    write("Верхняя треугольная матрица U:")
    write(U)
    
    # L*y = b
    y = forward_substitution(L, b)
    
    # U*x = y
    x = backward_substitution(U, y)
    
    write("Найденный вектор решений x:")
    write(x)
```

---

### Пример 2: Генерация и обработка данных с помощью лямбд и файлов


```mcl
# ==============================================================================
# Пример 2: Функциональная генерация данных, файловый ввод/вывод и обработка
# Демонстрирует:
# - Создание матриц с помощью лямбда-функций.
# - Использование условного выражения (тернарного оператора).
# - Итерацию по матрице (построчно).
# - Явное преобразование типов (int) -> (float).
# - Работу с файлами: write_file() и read_file().
# - Использование встроенных утилитных функций (triag_upper, dimension).
# ==============================================================================

# Демонстрация синтаксиса лямбд с тернарным оператором для создания "рамочной" матрицы 5x5.
frame_matrix = [5][5](lambda r, c: 1 if r == 0 or r == 4 or c == 0 or c == 4 else 0)

write("Сгенерированная рамочная матрица:")
write(frame_matrix)

# Сохранение матрицы в .csv файл
write_file("frame_data.csv", frame_matrix)
write("Матрица сохранена в frame_data.csv")

# Загрузка данных из файла
loaded_matrix = read_file("frame_data.csv")


# Встроенная функция, вычисляющая размерность матриц и векторов
dims = dimension(loaded_matrix)
rows = dims[0]
cols = dims[1]
total_sum = 0.0

# Демонстрация итерации for..in по матрице
for row_vec in loaded_matrix:
    for element in row_vec:
        total_sum = total_sum + element

# Явное преобразование типов для корректного деления.
average = total_sum / (float)(rows * cols)

write("Среднее значение элементов в загруженной матрице:")
write(average)

# Работа встроенной функции для треугольных матриц.
upper_frame = triag_upper(frame_matrix)
write("Верхняя треугольная часть рамочной матрицы:")
write(upper_frame)
```

---

### Пример 3: Интерактивный итерационный процесс

```mcl
# ==============================================================================
# Пример 3: Итерационный алгоритм (метод простой итерации) с валидацией ввода
# Демонстрирует:
# - Циклы while и until для управления потоком выполнения.
# - Интерактивный ввод/вывод с помощью read() и write().
# - Использование строкового типа string и логического boolean.
# - Сложные логические условия с and, or, not.
# - Неявное объявление и изменение переменных в циклах.
# - Опциональное явное объявление типа с `?`.
# ==============================================================================

# Инициализация матрицы и вектора
A = {{0.2, 0.1}, {-0.1, 0.3}}
b = {1.0, 2.0}

write("Запускаем итерационный процесс x_k+1 = A * x_k + b")
write("Матрица A:")
write(A)

# Опциональное явное объялвение переменных
int? max_iterations = 15
float? tolerance = 0.001
boolean? converged = false

# Инициализация начальное приближение x_0.
x_prev = zeros(2)
iter_count = 0

# Основной цикл вычислений. Демонстрирует while и сложное условие.
while iter_count < max_iterations and not converged:
    x_next = (A * x_prev) + b
    
    diff_norm = |x_next - x_prev|
    
    if diff_norm < tolerance:
        converged = true
        write("Алгоритм сошелся!")

    x_prev = x_next
    iter_count = iter_count + 1
    
    write("Итерация:")
    write(iter_count)
    write(x_prev)

# Проверка результата цикла
if not converged:
    write("Алгоритм не сошелся за максимальное число итераций.")

write("Финальный результат:")
write(x_prev)

# Демонстрация цикла `until` для валидации пользовательского ввода.
confirm = ""
until confirm == "exit" or confirm == "quit":
    write("Введите 'exit' или 'quit' для завершения программы:")
    # Неявное объявление переменной `confirm` типа string.
    confirm = read()

write("Программа завершена.")
```

