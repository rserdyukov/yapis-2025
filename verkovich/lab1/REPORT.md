# Лабораторная работа 1

## Задача

Написать 3 примера фрагментов кода языка по варианту, все свойства должны быть использованы, встроенные типы, операции и функции должны быть использованы и показаны на примерах.

### Вариант задания

Вариант 2

Требования к разрабатываемому языку:
- Встроенные типы не менее трех
- Возможность инициализация переменных всех типов при объявлении: <тип>? <имя_переменной> = <выражение>
- Инициализирующее выражение может быть константным
- Встроенные операции не менее 10 штук
- Встроенные функции
- Встроенные функции ввода\вывода для работы со встроенными типами read() write()
- Использование сложных выражений (составных и со скобками)
- Блочный оператор
- Управляющие структуры
- Условный оператор (if-then-else)
- Операторы цикла (while и until)
- Оператор цикла с итерациями (for)
- Пользовательские подпрограммы
- Передача и возврат параметров
- Задание локальной и глобальной области видимости для имен переменных


Свойства языка:
- Объявление переменных - **Не явное**
- Преобразование типов - **Явное, например, a = (int) b**
- Оператор присваивания - **Одноцелевой, например, a = b**
- Структуры, ограничивающие область видимости - **Подпрограммы**
- Маркер блочного оператора - **Не явный, например как в python**
- Условные операторы - **Двух вариантный оператор if-then-else**
- Перегрузка подпрограмм - **Отсутствует**
- Передача параметров в подпрограмму - **Только по значению и возвращаемому значению**
- Допустимое место объявления подпрограмм - **В начале программы**

Вариант языка:
Язык для работы с векторами и матрицами
 - Встроенные типы: vector, matrix
 - Операции: 
    - v + v
    - v - v
    - n * v
    - v * v
    - |v|
    - m + m
    - m - m
    - m * n
    - m * m
    - m[n]
    - m[n] * n
    - |m|
    - v * m


Вариант целевого кода:
 - байт-код аля CPython (.pyc)

---

## Отчёт о выполнении лабораторной работы

В рамках данной работы были написаны фрагменты кода на языке матричных вычислений (MCL), отвечающих требованиям к языку по варианту, которые позволяют продемонстрировать основные синтаксические и семантические особенности языка. 

В комментариях к коду поясняется, как та или иная конструкция удовлетворяет свойствам, определённым в задании, отмечаются синтаксические или семантические особенности языка.

### Пример 1: Нормализация вектора и базовые операции

**Задача:** Этот пример демонстрирует определение и вызов пользовательской функции, базовый ввод/вывод, работу со скалярами, векторами и матрицами, а также условный оператор `if-else`.

```
# ==============================================================================
# Пример 1: Нормализация вектора и базовые операции
# ==============================================================================

# -- Определение пользовательских функций должно быть в начале программы.

# Функция для нормализации вектора (превращения его в единичный вектор).
# Демонстрирует:
# - Определение пользовательской функции `normalize`.
# - Передачу параметров по значению (`v` - это копия).
# - Область видимости, ограниченную подпрограммой (`norm` - локальная переменная).
func normalize(v: vector) -> vector:
    norm = |v| # Операция: модуль вектора |v|.

    # Демонстрация двухвариантного условного оператора if-then-else.
    # Блоки определяются отступами (неявный маркер).
    if norm == 0.0:
        write("Внимание: Попытка нормализовать нулевой вектор.")
        return v # Возвращаем исходный нулевой вектор.
    else:
        # Операция: умножение вектора на скаляр n * v.
        # Возвращаем значение из функции.
        return v * (1.0 / norm)

# --- Начало основной программы ---

# Демонстрация неявного объявления переменных и одноцелевого присваивания.
# Встроенные типы: int, float, boolean, vector, matrix.
pi_approx = 3.14159       # Тип float (выводится по наличию точки)
is_active = true          # Тип boolean
cycles_count = 10         # Тип int

write("--- Демонстрация базовых типов и операций ---")
write(pi_approx)
write(is_active)

# Инициализация вектора и матрицы.
input_vec = {5.0, 12.0, 0.0}
rotation_matrix = {{0, -1}, {1, 0}} # Матрица поворота на 90 градусов

# Вызов встроенной функции write() для вывода сложных типов.
write("Исходный вектор:")
write(input_vec)

# Вызов пользовательской функции.
normalized_vec = normalize(input_vec)

write("Нормализованный вектор:")
write(normalized_vec)

# Демонстрация операций: v * v (скалярное произведение)
dot_product = normalized_vec * normalized_vec
write("Скалярное произведение нормализованного вектора на себя (должно быть ~1.0):")
write(dot_product)

# Демонстрация операций: m + m (сложение матриц)
# Используем встроенную функцию identity() для создания единичной матрицы.
m1 = identity(2)
m2 = {{1, 2}, {3, 4}}
m_sum = m1 + m2
write("Сумма единичной матрицы и матрицы m2:")
write(m_sum)
```

---

### Пример 2: Итерационные вычисления и области видимости

**Задача:** Этот пример показывает использование циклов `for` и `while`, работу с глобальными и локальными переменными, а также демонстрирует операции итерации по матрице и транспонирование.

```
# ==============================================================================
# Пример 2: Итерационные вычисления и области видимости
# ==============================================================================

# Глобальная переменная, доступная везде в программе.
GLOBAL_THRESHOLD = 0.5

# Функция для проверки, есть ли в матрице строка, норма которой превышает порог.
# Демонстрирует:
# - Доступ к глобальной переменной (GLOBAL_THRESHOLD).
# - Локальную область видимости (`row`, `norm`).
# - Итерационный цикл `for` для обхода строк матрицы.
func check_matrix_stability(m: matrix) -> boolean:
    is_stable = true
    
    # Цикл for итерируется по строкам матрицы `m`.
    # `row` на каждой итерации становится вектором.
    for row in m:
        norm = |row|
        if norm > GLOBAL_THRESHOLD:
            is_stable = false
    
    return is_stable

# --- Начало основной программы ---

# Создаем матрицу с помощью встроенных функций ones() и range().
# v_range будет {0, 1, 2}. Матрица будет 3x3.
v_range = range(3)
M1 = ones(3, 3) * v_range # Демонстрация операции m * v (поэлементное умножение строки)

write("--- Итерационные вычисления и работа с матрицами ---")
write("Исходная матрица M1:")
write(M1)

# Демонстрация транспонирования с помощью встроенной функции transpose().
M2 = transpose(M1)
write("Транспонированная матрица M2:")
write(M2)

# Демонстрация операции m * m (матричное умножение).
M_prod = M1 * M2
write("Произведение M1 * M2:")
write(M_prod)

# Проверяем "стабильность" матрицы, вызывая нашу функцию.
stability = check_matrix_stability(M_prod)
write("Матрица M_prod 'стабильна' (все нормы строк < 0.5)?")
write(stability)

# Демонстрация условного цикла `while`.
# Неявное объявление переменной `counter`.
counter = 3
write("Обратный отсчет с помощью цикла while:")
while counter > 0:
    write(counter)
    counter = counter - 1 # Операция v - v (для скаляров)
```

---

### Пример 3: Решение системы линейных уравнений 2x2

**Задача:** Этот пример решает практическую задачу, используя определитель матрицы, явное преобразование типов и интерактивный ввод данных для демонстрации оставшихся свойств и операций.

```
# ==============================================================================
# Пример 3: Решение системы линейных уравнений 2x2 методом Крамера
# ==============================================================================

# Для системы A*x = b, решение: x_i = det(A_i) / det(A)

# Эта функция демонстрирует:
# - Сложные выражения со скобками.
# - Явное преобразование типов: (float).
# - Операции |m| (определитель), m[n] (доступ к строке).
# - Использование неявных блоков в if-else.
func solve_2x2_system(A: matrix, b: vector) -> vector:
    # Проверяем, что матрица A квадратная и 2x2
    dims = dimension(A)
    if dims[0] != 2 or dims[1] != 2:
        write("Ошибка: Матрица A должна быть 2x2.")
        return zeros(2)
        
    det_A = |A|
    
    if det_A == 0:
        write("Система не имеет единственного решения (определитель равен нулю).")
        return zeros(2)
    else:
        # Создаем матрицу A_x, заменяя первый столбец на вектор b
        A_x = {{b[0], A[0][1]}, {b[1], A[1][1]}}
        det_Ax = |A_x|
        
        # Создаем матрицу A_y, заменяя второй столбец на вектор b
        A_y = {{A[0][0], b[0]}, {A[1][0], b[1]}}
        det_Ay = |A_y|
        
        # Вычисляем решение.
        # Демонстрируем ЯВНОЕ ПРЕОБРАЗОВАНИЕ ТИПОВ. Если det_A был int,
        # для корректного деления мы преобразуем его во float.
        x = det_Ax / (float)det_A
        y = det_Ay / (float)det_A
        
        return {x, y}

# --- Начало основной программы ---

write("--- Решение системы линейных уравнений A*x = b ---")
write("Введите матрицу коэффициентов A (например, {{2, 3}, {1, 4}}):")
A_input = read()

write("Введите вектор свободных членов b (например, {8, 9}):")
b_input = read()

# Вызов функции для решения системы.
solution = solve_2x2_system(A_input, b_input)

write("Вектор решений x:")
write(solution)

# Демонстрация операции v * m
# Проверим решение: A * x должно быть равно b
check_vec = solution * A_input
write("Проверка: solution * A (должно быть равно b):")
write(check_vec)

# Демонстрация цикла `until`
input_ok = false
until input_ok:
    write("Введите 'ok' для завершения:")
    confirm = read()
    if confirm == "ok":
        input_ok = true

write("Программа завершена.")
```